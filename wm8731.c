/**
  * @file wm8731.c
  * @author generated by mrt-device utility 
  * @link [https://github.com/uprev-mrt/mrtutils/wiki/mrt-device]
  * @brief Device driver for wm8731 device
  *
  */

#include "wm8731.h"



/**
 * @brief initializes device
 * @param dev ptr to wm8731 device
 * @return status 
 */
static mrt_status_t wm_init(wm8731_t* dev)
{   
    /* Initialize Register Descriptors */
    REG_INIT( dev->mLeftIn , WM_REG_LEFT_IN_ADDR , uint16_t, REG_PERM_W , 0x0097  );
    REG_INIT( dev->mRightIn , WM_REG_RIGHT_IN_ADDR , uint16_t, REG_PERM_W , 0x0097  );
    REG_INIT( dev->mLeftOut , WM_REG_LEFT_OUT_ADDR , uint16_t, REG_PERM_W , 0x0079  );
    REG_INIT( dev->mRightOut , WM_REG_RIGHT_OUT_ADDR , uint16_t, REG_PERM_W , 0x0079  );
    REG_INIT( dev->mAnPath , WM_REG_AN_PATH_ADDR , uint16_t, REG_PERM_W , 0x000A  );
    REG_INIT( dev->mDigPath , WM_REG_DIG_PATH_ADDR , uint16_t, REG_PERM_W , 0x0008  );
    REG_INIT( dev->mPowerDwn , WM_REG_POWER_DWN_ADDR , uint16_t, REG_PERM_W , 0x009F  );
    REG_INIT( dev->mDigIface , WM_REG_DIG_IFACE_ADDR , uint16_t, REG_PERM_W , 0x009F  );
    REG_INIT( dev->mSample , WM_REG_SAMPLE_ADDR , uint16_t, REG_PERM_W , 0x0000  );
    REG_INIT( dev->mActive , WM_REG_ACTIVE_ADDR , uint16_t, REG_PERM_W , 0x0000  );
    REG_INIT( dev->mReset , WM_REG_RESET_ADDR , uint16_t, REG_PERM_W , 0x0FFF  );


    /*user-block-init-start*/

    /*user-block-init-end*/

    return MRT_STATUS_OK;
}


mrt_status_t wm_init_i2c(wm8731_t* dev, mrt_i2c_handle_t i2c)
{
    mrt_status_t status;

    status = init_i2c_register_device(&dev->mRegDev, i2c, WM8731_I2C_ADDRESS, WM8731_REG_ADDR_SIZE );

    wm_init(dev);


    /*user-block-init-i2c-start*/

    /* Assign the custom write function to the RegDev because device does not us standard I2C register access */
    dev->mRegDev.fWrite = wm8731_write_i2c;

    /*user-block-init-i2c-end*/
    
    return status;
}
mrt_status_t wm_init_spi(wm8731_t* dev, mrt_spi_handle_t spi, mrt_gpio_t chipSelect)
{
    mrt_status_t status;

    status = init_spi_register_device(&dev->mRegDev, spi, chipSelect, WM8731_REG_ADDR_SIZE );

    wm_init(dev);

    /*user-block-spi-start*/

    /* Assign the custom write function to the RegDev because device does not us standard I2C register access */
    dev->mRegDev.fWrite = wm8731_write_spi;

    /*user-block-spi-end*/

    return status;
}

mrt_status_t wm_test(wm8731_t* dev)
{
    mrt_status_t status = MRT_STATUS_ERROR;
    /*user-block-test-start*/

    /* No default test because device is write-only */
    return MRT_STATUS_ERROR;    //Return error so nobody relies on this test

    /*user-block-test-end*/
    return status;
}


/*user-block-bottom-start*/

void wm_set_volume(wm8731_t* dev, uint8_t left, uint8_t right)
{
    /*Converted values for register*/
    uint8_t leftVal = ((int)left * WM_LEFT_IN_VOLUME_MAX) / 100;
    uint8_t rightVal = ((int)right * WM_RIGHT_IN_VOLUME_MAX)/ 100;

    /* Set volume fields */
    wm_set_left_in_volume(dev, leftVal);
    wm_set_right_in_volume(dev, rightVal); 
}


mrt_status_t wm8731_write_i2c(mrt_regdev_t* dev, uint32_t addr, uint8_t* data,int len)
{
    /* wm8731 treats registers as 9 bits of data with a 7bit address. so we shift the LSB of the second byte into the address.. */
    addr = (addr << 1) | (data[1] & 0xFE);
    
    /* Once we have shifted the 9th data bit into the address, we can write the remainder as a single byte*/
    return MRT_I2C_MEM_WRITE(dev->mI2cHandle, dev->mAddr, addr, dev->mMemAddrSize , data, 1, dev->mTimeout );

}

mrt_status_t wm8731_write_spi(mrt_regdev_t* dev, uint32_t addr, uint8_t* data,int len)
{
    /* wm8731 treats registers as 9 bits of data with a 7bit address. so we shift the LSB of the second byte into the address.. */
    uint8_t packedData[2];
    packedData[0] = (addr << 1) | (data[1] & 0xFE);
    packedData[1] = data[0];
    
    /* Once we have shifted the 9th data bit into the address, we can write the remainder as a single byte*/
    return MRT_SPI_TRANSMIT(dev->mSpiHandle, packedData, 2, 1000);
}


/*user-block-bottom-end*/
